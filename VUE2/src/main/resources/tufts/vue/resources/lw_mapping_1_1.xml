<?xml version="1.0" encoding="utf-8" ?>
<!-- @version $Revision: 1. $ / $Date: 2006/01/20 17:17:29 $ / $Author: sfraize $ -->
<!-- This is version 1.1 of the mapping file. -->

<!-- The purpose of this file is to map save files for the given version of a VUE save
     file to the current version running version of VUE.  When the structure of the save
     file changes sufficiently that can't alter the existing mapping to support backward
     compatability, we create a new version of this file, which the new save files will
     use for mapping into VUE.

     While creating new versions of this file is good way to handle major changes,
     it has a high maintainance cost, as sometimes we make changes to the VUE saved data that
     require minor changes to the save format, but then we have to update
     all versions of the mapping file for it.

-->

<!-- Change log:
     1.1: MapResource spec changed from element to attribute to handle long paths with spaces (newlines were being added)
          and MapResource type changed from element to attribute while we were at it.
     8/18/05 SMF: made changes required for new castor version 0.9.7 which is
                  more demanding, tho more consistent & sane.  These changes should
                  only affect the interface to castor, and NOT the save file format,
                  so we're not adding a new version of this file.   These same
                  changes were made to all the other old mapping files.
     8/23/05 SMF: resource properties are now attributes, and backward compat with old resource save files
     3/28/06 SMF: MapResource becomes URLResource, as MapResource is now subclassed from it (MapResource a stub class
                  we're keeping only for backward compatability with old save files).  MapResource stub
                  replaces URLResource stub.  AssetResource also now subclasses URLResource v.s. MapResource (test this)
     2012-07 SMF: LWMergeMap hacked out.  On restore is converted to proper LWMap.
  -->
          
<mapping>
    <!-- Rectangle's default castor introspection produces a recursive
         loop (getBounds returns a Rectangle) that blows stack: this
         gets around it.  May need create also Rectangle2D.
      -->
  <!-- class name="java.awt.Rectangle">
    <field name="x" direct="true"><bind-xml node="attribute"/></field>
    <field name="y" direct="true"><bind-xml node="attribute"/></field>
    <field name="width" direct="true"><bind-xml node="attribute"/></field>
    <field name="height" direct="true"><bind-xml node="attribute"/></field>
  </class -->
  
  <class name="java.lang.String"><map-to xml="string"/></class>
  <class name="java.awt.geom.Point2D$Float">
    <map-to xml="point"/>
    <field name="x" direct="true"><bind-xml node="attribute"/></field>
    <field name="y" direct="true"><bind-xml node="attribute"/></field>
  </class>
  <class name="java.awt.Point">
    <map-to xml="pointi"/>
    <field name="x" direct="true"><bind-xml node="attribute"/></field>
    <field name="y" direct="true"><bind-xml node="attribute"/></field>
  </class>
  <!--class name="java.awt.geom.RectangularShape">
    <map-to xml="shape"/>
   
  </class -->
  <class name="tufts.vue.shape.RectangularPoly2D">
    <map-to xml="polygon"/>
    <field name="sides"><bind-xml node="attribute"/></field>
  </class>
  <class name="tufts.vue.shape.RectangularPoly2D$Triangle"><map-to xml="triangle"/></class>
  <class name="tufts.vue.shape.RectangularPoly2D$Shield"><map-to xml="shield"/></class>
  <class name="tufts.vue.shape.RectangularPoly2D$Flag"><map-to xml="flag"/></class>
  <class name="tufts.vue.shape.RectangularPoly2D$Flag2"><map-to xml="flag2"/></class>
  <class name="tufts.vue.shape.RectangularPoly2D$Diamond"><map-to xml="diamond"/></class>
  <class name="tufts.vue.shape.RectangularPoly2D$Hexagon"><map-to xml="hexagon"/></class>
  <class name="tufts.vue.shape.RectangularPoly2D$Pentagon"><map-to xml="pentagon"/></class>
  <class name="tufts.vue.shape.RectangularPoly2D$Chevron"><map-to xml="chevron"/></class>
  <class name="tufts.vue.shape.RectangularPoly2D$Octagon"><map-to xml="octagon"/></class>
  <class name="tufts.vue.shape.RectangularPoly2D$Rhombus"><map-to xml="rhombus"/></class>
  <class name="tufts.vue.shape.RoundRect2D"><map-to xml="roundRect"/>
    <field name="arcwidth" direct="true"><bind-xml node="attribute"/></field>
    <field name="archeight" direct="true"><bind-xml node="attribute"/></field>
  </class>
  <class name="java.awt.geom.Rectangle2D$Float">
    <map-to xml="rectangle"/>
    <field name="x"      direct="true" transient="true" type="float"><bind-xml node="attribute"/></field>
    <field name="y"      direct="true" transient="true" type="float"><bind-xml node="attribute"/></field>
    <field name="width"  direct="true" transient="true" type="float"><bind-xml node="attribute"/></field>
    <field name="height" direct="true" transient="true" type="float"><bind-xml node="attribute"/></field>
  </class>
  <class name="java.awt.geom.Ellipse2D$Float">
    <map-to xml="ellipse"/>
  </class>
  <class name="java.awt.geom.RoundRectangle2D$Float">
    <map-to xml="roundRectRaw"/>
    <field name="arcwidth" direct="true"><bind-xml node="attribute"/></field>
    <field name="archeight" direct="true"><bind-xml node="attribute"/></field>
  </class>
  <class name="java.awt.Dimension">
    <field name="width" direct="true"><bind-xml node="attribute"/></field>
    <field name="height" direct="true"><bind-xml node="attribute"/></field>
  </class>

  <class name="tufts.vue.MetaMap">
    <field name="schema">
      <bind-xml name="schema" node="attribute" reference="true"/>
    </field>
    <field name="persistEntries" type="tufts.vue.PropertyEntry" collection="collection">
      <bind-xml name="data" node="element"/>
    </field>
  </class>


  <class name="edu.tufts.vue.metadata.VueMetadataElement">
    <!-- Note that unless/until we fix the VME crazy hack in setType, it must always be the LAST field as it
         has side effects that depend on the other fields, and can change them.
    -->
    <field name="XMLtype">
      <bind-xml name="t" node="attribute"/>
    </field>
    <field name="key" type="java.lang.String">
      <bind-xml name="k" node="attribute"/>
    </field>
    <field name="value" type="java.lang.String">
      <bind-xml name="v" node="attribute"/>
    </field>
    <!-- for backward compat with old save files: setters work, getters always return null -->
    <field name="setterKey" type="java.lang.String">
      <bind-xml name="key" node="element"/>
    </field>
    <field name="setterValue" type="java.lang.String">
      <bind-xml name="value" node="element"/>
    </field>
    <field name="setterType">
      <bind-xml name="type" node="element" type="java.lang.String"/>
    </field>
    <!-- <field name="type"/> above should be same as this -->
    <!-- end backward compat with old save files -->
  </class>
  <class name="edu.tufts.vue.metadata.MetadataList">
    <field name="XMLdata" collection="collection" type="edu.tufts.vue.metadata.VueMetadataElement">
      <bind-xml name="md"/>
    </field>
    <!-- for backward compat with old save files: setters work, getters always return null -->
    <field name="setterXMLdata" collection="collection" type="edu.tufts.vue.metadata.VueMetadataElement">
      <bind-xml name="metadata"/>
    </field>
  </class>
  
  <class name="tufts.vue.LWComponent" identity="ID">
    <!-- castor can figure out types, we leave string as defaulted.
      -->
                <map-to xml="LWC"/>
                
                <field name="ID"><bind-xml node="attribute"/></field>
		<field name="XMLlabel"><bind-xml name="label" node="attribute"/></field>
		<field name="labelFormat"><bind-xml name="labelFormat" node="element"/></field>

		<field name="persistLayer" type="tufts.vue.LWMap$Layer">
                  <bind-xml name="layerID" node="attribute" reference="true"/>
                </field>

		<field name="created"><bind-xml name="created" node="attribute"/></field>
		<field name="XMLnotes"><bind-xml name="notes" node="element"/></field>

                <!-- This only applies to LWMap, but we put it here as we want it to come BEFORE the children in the persist order
                 for the schema-id references it provides for subsequent dataMaps -->
		<field name="includedSchemas" type="tufts.vue.ds.Schema" collection="collection">
		  <bind-xml name="schema"/>
		</field>

		<field name="resource" type="tufts.vue.Resource">
			<bind-xml name="resource" node="element"/>
		</field>

		<!--field name="persistDataMap" collection="collection"-->
		<field name="persistDataMap" type="tufts.vue.MetaMap">
                  <bind-xml name="dataMap" node="element"/>
                </field>
                

		<field name="x" type="float">   <bind-xml node="attribute"/></field>
		<field name="y" type="float">   <bind-xml node="attribute"/></field>
		<field name="width">    <bind-xml name="width" node="attribute"/></field>
		<field name="height">   <bind-xml name="height" node="attribute"/></field>
		<field name="XMLfillColor">     <bind-xml name="fillColor" node="element"/></field>
		<field name="XMLstrokeColor">   <bind-xml name="strokeColor" node="element"/></field>
		<field name="XMLtextColor">     <bind-xml name="textColor" node="element"/></field>
		<field name="XMLfont">          <bind-xml name="font" node="element"/></field>
		<field name="XMLhidden">        <bind-xml name="hidden" node="attribute"/></field>
		<field name="XMLpruned">        <bind-xml name="pruned" node="attribute"/></field>
		<field name="XMLlocked">        <bind-xml name="locked" node="attribute"/></field>
		<field name="XMLtextBox">       <bind-xml name="textBox" node="element"/></field>
                <field name="strokeWidth">      <bind-xml name="strokeWidth" node="attribute"/></field>
		<field name="XMLstrokeStyle">   <bind-xml name="strokeStyle" node="attribute"/></field>
                
		<field name="autoSized" type="boolean"><bind-xml name="autoSized" node="attribute"/></field>
                
		<field name="style" type="tufts.vue.LWComponent">
                  <bind-xml name="styleID" node="attribute" reference="true"/>
                </field>
                
		<field name="syncSource" type="tufts.vue.LWComponent">
                  <bind-xml name="syncID" node="attribute" reference="true"/>
                </field>
  
                <field name="persistIsStyle" type="boolean">
                  <bind-xml name="isStyle" node="attribute"/>
                </field>

                <field name="persistIsSlideStyled" type="boolean">
                  <bind-xml name="isSlideStyle" node="attribute"/>
                </field>
                
                                   
                <!-- tmp back compat -->
		<field name="parentStyle" type="tufts.vue.LWComponent">
                  <bind-xml name="parentStyleID" node="attribute" reference="true"/>
                </field>
		<field name="persistIsStyleParent" type="boolean">
                  <bind-xml name="isStyleParent" node="attribute"/>
                </field>
                
                <!-- temporarily(?) return to old node filter get method -->
                <!-- field name="nodeFilter" get-method="XMLnodeFilter">      <bind-xml name="nodeFilter" node="element"/></field -->
                <!-- field name="nodeFilter">      <bind-xml name="nodeFilter" node="element"/></field --> 
                <field name="XMLnodeFilter">      <bind-xml name="nodeFilter" node="element"/></field>
                
                <field name="XMLmetadataList">
                  <bind-xml name="metadata-list"/>
                </field>
                
                <field name="URIString" />
                <!-- We can save a shape interface, but it won't restore properly -->
		<!-- field name="shape" type="java.awt.Shape">
			<bind-xml name="shape" node="element"/>
		</field -->
                <!-- -->

                <!--
                <field name="extraTags" set-method="addObject" type="java.lang.Object" collection="arraylist">
                        <bind-xml matches="*"/> 
                </field>
                -->
                
	</class>

	<class name="tufts.vue.LWContainer" extends="tufts.vue.LWComponent">
          <field name="XMLChildList" type="tufts.vue.LWComponent" collection="arraylist">
            <bind-xml name="child"/>
          </field>
        </class>

	<class name="tufts.vue.LWMap$Layer" extends="tufts.vue.LWContainer">
          <map-to xml="layer"/>
        </class>
        
	
	<class name="tufts.vue.LWGroup" extends="tufts.vue.LWContainer">
		<map-to xml="group"/>
	</class>
	<class name="tufts.vue.LWSlide" extends="tufts.vue.LWContainer">
		<map-to xml="slide"/>
		<!-- field name="layer"><bind-xml name="layer" node="element"/></field> -->
	</class>
	<class name="tufts.vue.LWText" extends="tufts.vue.LWComponent">
		<map-to xml="text"/>	
				 <field name="richText"  node="attribute" type="string">
        	<bind-xml name="richText" />
    	</field>
    	<field name="label"  node="attribute" type="string">
        	<bind-xml name="label" />
    	</field>
    	
	</class>
	<class name="tufts.vue.MasterSlide" extends="tufts.vue.LWSlide">
		<map-to xml="masterSlide"/>
                <field name="titleStyle" type="tufts.vue.LWComponent">
                  <bind-xml name="titleStyle"/>
                </field>
                <field name="textStyle" type="tufts.vue.LWComponent">
                  <bind-xml name="textStyle"/>
                </field>
                <field name="linkStyle" type="tufts.vue.LWComponent">
                  <bind-xml name="linkStyle"/>
                </field>
	</class>

        
	<class name="tufts.vue.LWNode" extends="tufts.vue.LWContainer">
		<map-to xml="node"/>
		<!-- field name="nodeShape">
			<bind-xml name="nodeShape" node="element"/>
		</field -->
		<field name="XMLshape">
                  <bind-xml name="shape" node="element"/>
		</field>
	</class>

	<class name="tufts.vue.LWPortal" extends="tufts.vue.LWNode">
		<map-to xml="portal"/>
	</class>
        
	<class name="tufts.vue.LWImage" extends="tufts.vue.LWComponent">
		<map-to xml="image"/>
		<field name="offset">
			<bind-xml name="offset" node="element"/>
		</field>
	</class>
	
	<class name="tufts.vue.LWLink" extends="tufts.vue.LWComponent">
		<map-to xml="link"/>
	        <field name="headPoint">
			<bind-xml name="point1" node="element"/>
		</field>
	        <field name="tailPoint">
			<bind-xml name="point2" node="element"/>
		</field>
                
		<field name="persistHead">
		  <bind-xml name="ID1" node="element" reference="true"/>
		</field>
                
		<field name="persistTail">
		  <bind-xml name="ID2" node="element" reference="true"/>
		</field>
                
	        <field name="controlCount">
			<bind-xml name="controlCount" node="attribute"/>
		</field>
	        <field name="arrowState">
			<bind-xml name="arrowState" node="attribute"/>
		</field>
                <!-- if isn't curved, these will be null, and thus not saved. so if this
                     is present, we know it's a curved link-->
	        <field name="ctrlPoint0">
			<bind-xml name="ctrlPoint0" node="element"/>
		</field>
	        <field name="ctrlPoint1">
			<bind-xml name="ctrlPoint1" node="element"/>
		</field>
                <!-- bits for user-applied pruning -->
	        <field name="headUserPruned">
                  <bind-xml name="headUserPruned" node="element"/>
		</field>
	        <field name="tailUserPruned">
                  <bind-xml name="tailUserPruned" node="element"/>
		</field>
                
	</class>

	<class name="tufts.vue.LWMap" extends="tufts.vue.LWContainer">
		<map-to xml="LW-MAP"/>
                
		<!--field name="includedAssociations" type="tufts.vue.ds.Association" collection="collection">
		  <bind-xml name="association"/>
		</field-->
                
                <field name="XMLLayers" type="tufts.vue.LWMap$Layer" collection="arraylist">
                  <bind-xml name="layer"/>
                </field>
                
		<field name="userZoom">
			<bind-xml name="userZoom"/>
		</field>
		<field name="userOrigin">
			<bind-xml name="userOrigin" node="element"/>
		</field>		
		<field name="searchArrLst" type="tufts.vue.SearchData" collection="arraylist">
                  <bind-xml name="searchArrLst"/>
                </field>
		<field name="presentationBackground">
		  <bind-xml name="presentationBackground" node="element"/>
		</field>		
		<!-- field name="Pathways" type="tufts.vue.LWPathwayList" -->

		<field name="PathwayList">
			<bind-xml name="PathwayList" node="element"/>
		</field>
                
                <field name="author">
                    <bind-xml name="author" node="element"/>
                </field>
                <field name="date">
                    <bind-xml name="date"  node="element"/>
                </field>
                <field name="description">
                    <bind-xml name="description" node="element"/>
                 </field>
                 <field name="mapFilterModel">
                    <bind-xml name="mapFilterModel" node="element"/>
                 </field> 
                 <field name="modelVersion">
                   <bind-xml name="modelVersion" node="element"/>
                 </field> 
                 <field name="saveLocation">
                   <bind-xml name="saveLocation" node="element"/>
                 </field> 
                 <field name="saveFile">
                   <bind-xml name="saveFile" node="element"/>
                 </field>

                <field name="archiveManifest" type="tufts.vue.PropertyEntry" node="element" collection="collection">
		  <bind-xml name="archive"/>
		</field>
                 
                <field name="extraTags" set-method="addObject" type="java.lang.Object" collection="arraylist">
                  <bind-xml matches="*"/> 
                </field>
        
	</class>
        
        <class name="tufts.vue.action.ActionUtil$OLD_MERGE_MAP_STUB" extends="tufts.vue.LWMap">
          <!-- Include only the "map-to" tag and leave everything else empty, so it will be ignored during
               load.  (And we've hacked our XMLObjectFactory to actually return an LWMap when an LWMergeMap is
               requested). Note that the stub MUST extend LWMap for this to work.  SMF 2012-07 -->
          <!-- It bas a bad idea to persist an LWMergeMap in the first place.  We're doing this now as some
               save files of LWMergeMaps are going haywire when they're saved/resaved and growing to hundredes
               of megabytes in size. SMF 2012-07 -->
          <map-to xml="LW-MERGE-MAP" />
	</class>
            
        <!-- <class name="tufts.vue.LWMergeMap$HIDE_FROM_CASTOR_MAPPING" extends="tufts.vue.LWMap"> -->
        <!--     <map-to xml="LW-MERGE-MAP-NO-LONGER-USED" /> -->
        <!--     <field name="mapListSelectionType"> -->
        <!--         <bind-xml name="mapListSelectionType" node="element"/> -->
        <!--     </field> -->
        <!--     <field name="mapList" type="tufts.vue.LWMap" collection="arraylist"> -->
        <!--         <bind-xml name="mapList"/> -->
        <!--     </field> -->
        <!--     <field name="mapFileList" type="java.lang.String" collection="arraylist"> -->
        <!--         <bind-xml name="mapFileList" /> -->
        <!--     </field> -->
        <!--     <field name="activeFileList" type="java.lang.Boolean" collection="arraylist"> -->
        <!--         <bind-xml name="activeFileList" /> -->
        <!--     </field> -->
        <!--     <field name="baseMapSelectionType"> -->
        <!--         <bind-xml name="baseMapSelectionType" node="element"/> -->
        <!--     </field> -->
        <!--     <field name="baseMap" type="tufts.vue.LWMap" > -->
        <!--         <bind-xml name="baseMap" node ="element"/> -->
        <!--     </field> -->
        <!--     <field name="visualizationSelectionType"> -->
        <!--         <bind-xml name="visualizationSelectionType" node="element"/> -->
        <!--     </field> -->
        <!--     <field name="filterOnBaseMap"> -->
        <!--         <bind-xml name="filterOnBaseMap" node="element" /> -->
        <!--     </field> -->
        <!--     <field name="excludeNodesFromBaseMap"> -->
        <!--         <bind-xml name="excludeNodesFromBaseMap" node="element" /> -->
        <!--     </field> -->
        <!--     <field name="nodeThresholdSliderValue"> -->
        <!--         <bind-xml name="nodeSliderValue"/> -->
        <!--     </field> -->
        <!--     <field name="linkThresholdSliderValue"> -->
        <!--         <bind-xml name="linkSliderValue"/> -->
        <!--     </field> -->
        <!--     <field name="intervalBoundaries" type="java.lang.Double" collection="arraylist"> -->
        <!--         <bind-xml name="intervalBoundaries"/> -->
        <!--     </field> -->
        <!--     <field name="nodeIntervalBoundaries" type="java.lang.Double" collection="arraylist"> -->
        <!--         <bind-xml name="nodeIntervalBoundaries"/> -->
        <!--     </field> -->
        <!--     <field name="linkIntervalBoundaries" type="java.lang.Double" collection="arraylist"> -->
        <!--         <bind-xml name="linkIntervalBoundaries"/> -->
        <!--     </field> -->
        <!--     <field name="styleMapFile"> -->
        <!--         <bind-xml name="styleMapFile" node="element"/> -->
        <!--     </field> -->
        <!-- </class> -->
        
	<class name="tufts.vue.LWPathwayList">
		<map-to xml="PathwayList"/>
		<field name="currentIndex" type="integer">
			<bind-xml name="currentPathway" node="attribute" />
		</field>
		<field name="revealerIndex" type="integer">
			<bind-xml name="revealerIndex" node="attribute" />
		</field>
                <!-- This field def giving us a NPE in the latest version of castor! -->
                <!-- Is it because in the .vue file, it's an empty list? -->
                <!-- It seems to at least *save* if we change the collection kind from "collection" to "arraylist" -->
                <!-- Oh, crap.  It was just that the freakin type was missing, and apparently the new version
                     of castor doesn't notice that tufts.vue.LWPathway is mapped to "pathway" elsewhere like it used to -->
		<field name="elementList" type="tufts.vue.LWPathway" collection="collection">
			<bind-xml name="pathway"/>
		</field>
	</class>
	
	<class name="tufts.vue.LWPathway" extends="tufts.vue.LWContainer">
		<map-to xml="pathway"/>
		<field name="currentIndex" type="integer">
		  <bind-xml name="currentIndex" node="attribute"/>
		</field>
		<!--field name="locked" type="boolean">
		  <bind-xml name="locked" node="attribute"/>
		</field -->
		<field name="open" type="boolean">
		  <bind-xml name="open" node="attribute"/>
		</field>
                
		<field name="masterSlide" type="tufts.vue.MasterSlide">
		  <bind-xml name="masterSlide" node="element"/>
                </field>

                <field name="persistEntries" type="tufts.vue.LWPathway$Entry" collection="arraylist">
                  <bind-xml name="pathEntry"/>
                </field>
                
                <!-- field name="entries" type="tufts.vue.LWPathway$Entry" collection="arraylist"
                       get-method="iterateEntries" set-method="castorAddEntry">
                </field -->
                
		<field name="elementIDList" type="string" collection="collection">
		  <bind-xml name="id" />
		</field>
                <field name="elementPropertyList" type="tufts.vue.LWPathwayElementProperty" collection="collection">
                        <bind-xml name="ElementPropertyList" />
                </field>
	</class>
        
        <class name="tufts.vue.LWPathway$Entry">
          <map-to xml="pathEntry"/>
          <field name="mapView" get-method="isMapView" set-method="setMapView"><bind-xml name="isMapView" node="attribute"/></field>
          <field name="node" direct="true"><bind-xml name="nodeID" node="attribute" reference="true"/></field>
          <!--field name="notes"><bind-xml node="element"/></field -->
	  <field name="notes" get-method="XMLgetNotes" set-method="XMLsetNotes"><bind-xml name="notes" node="element"/></field>
	  <field name="persistSlide" type="tufts.vue.LWSlide">
	    <bind-xml name="slide" node="element"/>
          </field>
          
        </class>
        
        <class name="tufts.vue.LWPathwayElementProperty">
                <field name="elementID" type="string">
                        <bind-xml name="id" node="attribute"/>
                </field>
                <field name="elementNotes" type="string">
                  <bind-xml name="pathwayNotes" node="attribute"/>
                  <!-- We save as an attribue instead of an element to
                       get around potential bugs in castor element
                       saves of long strings.
                    -->
                </field>
        </class>

        <class name="tufts.vue.filter.MapFilterModel" > 
            <map-to xml="mapFilterModel"/>
            <field name="keyVector" type="tufts.vue.filter.Key" collection="vector">
                <bind-xml name="key"/>
            </field>
         </class>
         
          <class name="tufts.vue.filter.NodeFilter" > 
            <map-to xml="nodeFilter"/>
            <field name="statementVector" type="tufts.vue.filter.Statement" collection="vector">
                <bind-xml name="statement"/>
            </field>
         </class>
     
         <class name="tufts.vue.filter.Key">
            <map-to xml="key"/>
            <field name="sKey" set-method="setKey" get-method="getKey" type="java.lang.Object" >
                <bind-xml name="sKey" node="element" />
             </field>
             <field name="defaultValue" type="java.lang.Object" >
                <bind-xml name="defaultValue" node="element" />
             </field>
              <field name="type" type="tufts.vue.filter.Type" >
                <bind-xml name="type" node="element" />
             </field>
         </class>
          <class name="tufts.vue.filter.DefaultType">
            <map-to xml="defaultType"/>
            <field name="displayName" type="string">
		<bind-xml name="displayName" node="element" />
	     </field>
             <field name="operatorList" set-method="setOperators" get-method="getOperators"  collection="vector">
             </field>
         </class>
         <class name="tufts.vue.filter.IntegerType" extends="tufts.vue.filter.DefaultType">
                <map-to xml="integerType"/>
         </class>
         <class name="tufts.vue.filter.StringType" extends="tufts.vue.filter.DefaultType">
            <map-to xml="stringType"/>
         </class>
          <class name="tufts.vue.filter.BooleanType" extends="tufts.vue.filter.DefaultType">
            <map-to xml="booleanType"/>
         </class>
         
         <class name="tufts.vue.PropertyEntry">
            <map-to xml="property"/>
            <field name="entryKey" type="java.lang.String"><bind-xml name="key" node="attribute"/></field>
            <field name="entryValue" type="java.lang.Object"><bind-xml name="value" node="attribute"/></field>
            
            <!-- this hack allows us to READ any properties that were stored as an element,
                 but prevents us from ever writing one out as an element (it'll be written as an attribute as per above).
                 This technique can be used to switch between attribute and element in other areas we may need.
              -->
            <field name="IgnoredName1" type="java.lang.Object" set-method="setEntryValue" get-method="getNull">
                <bind-xml name="value" node="element"/>
            </field>
            <!-- If want to persist data other than strings in future for property values, could
            add an optional "objectValue" element which normally returns null (and so doesn't even
            appear in the save file), but if it's non-string data, castor could still serialize
            whatever object is there -->

            <!-- Backward compat for old save files in case they actually managed to save resource properties: -->
            <field name="IgnoredName2" type="java.lang.String" set-method="setEntryKey" get-method="getNull">
                <bind-xml name="entryKey" node="element"/>
            </field>
            <field name="IgnoredName3" type="java.lang.Object" set-method="setEntryValue" get-method="getNull">
                <bind-xml name="entryValue" node="element"/>
            </field>
            
         </class>

        
	<class name="tufts.vue.URLResource">
          
          
          <!-- this would allow us to rename "referenceCreated" to just "created" (by changing bind-xml below), but keeping in case of backward compat for now -->
          <!--field name="IgnoredName4" type="long" set-method="setReferenceCreated" get-method="getNull">
              <bind-xml name="referenceCreated" node="attribute"/>
          </field-->
                
		<field name="referenceCreated" type="long">
                  <bind-xml name="referenceCreated" node="attribute"/>
                </field>
                
		<field name="persistAccessAttempted">
                  <bind-xml name="accessAttempted" node="attribute"/>
                </field>
		<field name="persistAccessSuccessful">
                  <bind-xml name="accessSuccessful" node="attribute"/>
                </field>
                
		<field name="byteSize" get-method="getPersistByteSize">
                  <bind-xml name="size" node="attribute"/>
                </field>
                
		<!-- field name="spec"              type="string">  <bind-xml name="spec" node="attribute"/></field -->
		<field name="spec" type="string" set-method="XML_setSpec" get-method="getSpec">
                  <bind-xml name="spec" node="attribute"/>
                </field>
		<!-- field name="relativeURI"       type="string">  <bind-xml name="relativeURI" node="element"/></field -->
		<field name="title"             type="string">  <bind-xml name="title" node="element"/></field>
		<field name="clientType"        type="integer"> <bind-xml name="type" node="attribute"/></field>

                <field name="propertyList" type="tufts.vue.PropertyEntry" collection="collection">
			<bind-xml name="property"/>
		</field>
                
                <!-- field name="propertyMap" collection="map">
			<bind-xml name="property"/>
		</field -->
                <!-- field name="propertyList" type="tufts.vue.PropertyList" node="element">
			<bind-xml name="resourcePropertyList"/>
		</field -->

		<!--
		<field name="castorFedoraObject" type="tufts.vue.CastorFedoraObject">
			<bind-xml name="castorFedoraObject" node="element"/>
		</field>
		-->
	</class>

	
        <class name="tufts.vue.MapResource" extends="tufts.vue.URLResource"></class>
        
        <!-- class name="tufts.vue.PropertyList">
	  <bind-xml name="propertyList"/>
          <field type="tufts.vue.PropertyEntry" collection="arraylist">
	      <bind-xml name="property" />
	  </field>
	</class -->
                
	<class name="tufts.vue.AssetResource" extends="tufts.vue.URLResource">
		<field name="castorFedoraObject" type="tufts.vue.CastorFedoraObject">
			<bind-xml name="castorFedoraObject" node="element"/>
		</field>
	</class>
       
        <class name="tufts.vue.CabinetResource" extends="tufts.vue.URLResource">
            <map-to xml="cabinetResource"/>
	</class>
            <!-- getting rid of extension - why are we saving this?  do we even need a cabinet resource? -->
            <!-- field name="extension" type="string">
                <bind-xml name="extension" node="element"/>
             </field -->
		
	<class name="tufts.vue.Osid2AssetResource" extends="tufts.vue.URLResource">
		<field name="loadString" type="string">
		</field>
	</class>
       
		<!-- FEDORA OBJECTS -->
	<class name="tufts.vue.CastorFedoraObject">
		<field name="pid" type="string">
			<bind-xml name="pid" node="attribute"/>
		</field>
		<field name="fedoraType" type="string">
			<bind-xml name="fedoraType" node="element" />
		</field>
		<field name="displayName" type="string">
			<bind-xml name="displayName" node="element" />
		</field>
		<field name="CastorDR" type="tufts.vue.CastorDR">
			<bind-xml name="CastorDR" node="element"/>
		</field>
	</class>
	<class name="tufts.vue.CastorDR">
		<field name="id" type="string">
			<bind-xml name="id" node="attribute"/>
		</field>
		<field name="displayName" type="string">
			<bind-xml name="displayName" node="element" />
		</field>
		<field name="description" type="string">
			<bind-xml name="description" node="element" />
		</field>  
	   <field name = "address" type = "string">
			<bind-xml name ="address" node = "element" />
	   </field>
	   <field name = "userName" type = "string">
			<bind-xml name ="userName" node = "element" />
	   </field>
	   <field name = "password" type = "string">
			<bind-xml name ="password" node = "element" />
	   </field>
	   <field name="conf" type="string">
	   		<bind-xml name="conf" node="element" />
		</field>

	</class>
	

<!-- saving favorite nodes-->
	<class name="tufts.vue.SaveVueJTree">
		<map-to xml="SaveVueJTree" />
		<field name="saveTreeRoot" type="tufts.vue.SaveNode">
			<bind-xml name="SaveTreeRoot" node="element" />
		</field>
	</class>
	<class name="tufts.vue.SaveNode">
		<map-to xml="SaveNode" />
                <field name="resource" type="tufts.vue.Resource">
			<bind-xml name="resource" node="element"/>
		</field>
		
		<field name="children" type="tufts.vue.SaveNode" collection="vector">
			<bind-xml name="SaveNode" />
		</field>
	</class>
   
      

    <!--saving DataSourceViewer-->

<class name = "tufts.vue.SaveDataSourceViewer">
		<map-to xml ="SaveDataSourceViewer"/>
		
		<field name = "SaveDataSources" type = "tufts.vue.DataSource" collection = "vector">
			<bind-xml name ="dataSource" />
		</field>
		
</class>
<class name = "tufts.vue.BrowseDataSource">
       <map-to xml="tufts.vue.BrowseDataSource" />
       <field name="GUID" type="string">
         <bind-xml name="guid" node="element" />
       </field>
       
       <field name = "displayName" type = "string">
            <bind-xml name ="displayName" node = "element" />
       </field>
        
       <field name = "autoConnect" type = "boolean">
            <bind-xml name ="autoConnect" node = "attribute" />
       </field>
       
       <field name = "address" type = "string">
            <bind-xml name ="address" node = "element" />
       </field>
       
       <field name = "authenticationCookie" type = "string">
            <bind-xml name ="authentication" node = "element" />
       </field> 
 </class>
 <class name="tufts.vue.LocalFileDataSource" extends="tufts.vue.BrowseDataSource">
    <map-to xml="tufts.vue.LocalFileDataSource" />
</class>
<class name="tufts.vue.FavoritesDataSource" extends="tufts.vue.BrowseDataSource">
    <map-to xml="tufts.vue.FavoritesDataSource" />
    <field name = "saveFile" type="string">
        <bind-xml name="saveFile" node="element" />
     </field>
</class>
<class name="tufts.vue.RemoteFileDataSource" extends="tufts.vue.BrowseDataSource">
    <map-to xml="tufts.vue.RemoteFileDataSource" />
    <field name = "UserName" type = "string">
          <bind-xml name = "UserName" node = "element" />
    </field>
    <field name = "password" type = "string">
          <bind-xml name = "password" node = "element" />
    </field>
</class>
 <class name="edu.tufts.vue.rss.RSSDataSource" extends="tufts.vue.BrowseDataSource">
    <!-- map-to xml="edu.tufts.vue.rss.RSSDataSource" / -->
    <map-to xml="rssFeed" />
</class>
 <class name="tufts.vue.ds.XmlDataSource" extends="tufts.vue.BrowseDataSource">
    <map-to xml="xmlFeed" />
    <field name="itemKey" type="string">
          <bind-xml name="itemKey" node="element" />
    </field>
    <field name="keyField" type="string">
          <bind-xml name="keyField" node="element" />
    </field>
    <field name="imageField" type="string">
          <bind-xml name="imageField" node="element" />
    </field>
    <field name="encodingField" type="string">
          <bind-xml name="encodingField" node="element" />
    </field>
    <field name="matrixField" type="string">
          <bind-xml name="matrixField" node="element" />
    </field>
    <field name="matrixIgnoreField" type="string">
          <bind-xml name="matrixIgnoreField" node="element" />
    </field>
    <field name="matrixRelProcessField" type="string">
          <bind-xml name="matrixRelProcessField" node="element" />
    </field>    
     <field name="matrixRowField" type="string">
          <bind-xml name="matrixRowField" node="element" />
    </field>
     <field name="matrixColField" type="string">
          <bind-xml name="matrixColField" node="element" />
    </field>
     <field name="matrixRelField" type="string">
          <bind-xml name="matrixRelField" node="element" />
    </field>
    <field name="matrixFormatField" type="string">
          <bind-xml name="matrixFormatField" node="element" />
    </field>
    <field name="matrixPivotField" type="string">
          <bind-xml name="matrixPivotField" node="element" />
    </field>
        <field name="matrixStartRowField" type="string">
          <bind-xml name="matrixStartRowField" node="element" />
    </field>
        <field name="matrixSizeField" type="string">
          <bind-xml name="matrixSizeField" node="element" />
    </field>
 </class>
<!--

 <class name="tufts.vue.GoogleDataSource" extends="tufts.vue.VueDataSource">
       <field name = "url" type = "string">
          <bind-xml name = "url" node = "element" />
       </field> 
  <field name = "client" type = "string">
          <bind-xml name = "client" node = "element" />
       </field>
       <field name = "site" type = "string">
          <bind-xml name = "site" node = "element" />
       </field> 
	</class>

<class name="tufts.vue.OsidDataSource" extends="tufts.vue.VueDataSource">
	</class>
<class name="tufts.vue.Osid2DataSource" extends="tufts.vue.VueDataSource">
	</class>
        
        <class name="tufts.artifact.DataSource" extends="tufts.vue.VueDataSource">
	</class>
	<class name="tufts.vue.FedoraDataSource" extends="tufts.vue.VueDataSource">
      <field name = "UserName" type = "string">
          <bind-xml name = "UserName" node = "element" />
       </field>
       <field name = "password" type = "string">
          <bind-xml name = "password" node = "element" />
       </field>
        <field name = "port" type = "integer">
          <bind-xml name = "port" node = "element" />
       </field>

	</class>
-->        
        
<!-- support for datasources persistence -->
<class name="edu.tufts.vue.dsm.impl.VueDataSourceManager">
    <field name="dataSourceVector" type="edu.tufts.vue.dsm.DataSource" collection="vector">
        <bind-xml name="datasource"/>
    </field>
</class>

<class name="edu.tufts.vue.dsm.impl.VueDataSource">
    <map-to xml="edu.tufts.vue.dsm.impl.VueDataSource" />
    <field name="providerIdString" type="string">
        <bind-xml name="providerIdString" node="attribute" />
     </field>
    <field name="dataSourceIdString" type="string">
        <bind-xml name="dataSourceIdString" node="attribute" />
     </field>
     <field name="providerDisplayName" type="string">
        <bind-xml name="providerDisplayName" node="element" />
     </field>
     <field name="includedState" type="boolean" >
        <bind-xml name="includedState" node="attribute" />
     </field>
     <field name="propertyList" type="tufts.vue.PropertyEntry" collection="vector">
		<bind-xml name="propertyEntry" />
     </field>
</class>

<!-- mapping pertaining to saving ontolologies -->
<class name="edu.tufts.vue.ontology.OntManager" auto-complete="false">
    <map-to xml="edu.tufts.vue.ontology.OntManager" />
    <field name="ontList" type="edu.tufts.vue.ontology.Ontology" collection="arraylist">
        <bind-xml name="Ontology" />
    </field>
</class>
<class name="edu.tufts.vue.ontology.Ontology" auto-complete="false">
    <map-to xml="edu.tufts.vue.ontology.Ontology "/>
    <field name="base" node="attribute" type="string">
        <bind-xml name="base" />
    </field>
    <field name="label" node="attribute" type="string">
        <bind-xml name="label" />
    </field>
    <field name="cssFileName"  node="attribute" type="string">
        <bind-xml name="cssFileName" />
    </field>
</class>
<class name="edu.tufts.vue.ontology.OWLLOntology" extends="edu.tufts.vue.ontology.Ontology"  auto-complete="false"> 
    <map-to xml="edu.tufts.vue.ontology.OWLLOntology "/>
</class>
<class name="edu.tufts.vue.ontology.RDFSOntology" extends="edu.tufts.vue.ontology.Ontology"  auto-complete="false"> 
    <map-to xml="edu.tufts.vue.ontology.RDFSOntology "/>
</class>

<!--
<class name="tufts.vue.ds.Field" identity="mapLocalID">
 <field name="mapLocalID">
    <bind-xml name="ID" node="attribute"/>
  </field>
 -->
<class name="tufts.vue.ds.Field">
   <field name="name">
    <bind-xml name="name" node="attribute"/>
  </field>  
  <field name="styleNode" node="element" type="tufts.vue.LWComponent">
    <bind-xml name="styleNode"/>
  </field>
  
  <!--class name="tufts.vue.ds.Field$PersistRef"><map-to xml="fieldRef"/></class-->

  <field name="relatedFields" type="tufts.vue.ds.Field$PersistRef" collection="collection">
    <bind-xml name="relatedField"/>
  </field>
 
</class>

<class name="tufts.vue.ds.Schema" identity="mapLocalID">
  <field name="mapLocalID">
    <bind-xml name="ID" node="attribute"/>
  </field>  
  <field name="GUID" node="attribute" type="string">
    <bind-xml name="guid"/>
  </field>
  <field name="name" node="attribute" type="string">
    <bind-xml name="name"/>
  </field>
  <field name="resource" node="element" type="tufts.vue.Resource">
    <bind-xml name="resource"/>
  </field>
  <field name="rowNodeStyle" node="element" type="tufts.vue.LWComponent">
    <bind-xml name="rowNodeStyle"/>
  </field>
  <field name="XMLFields" type="tufts.vue.ds.Field" collection="arraylist">
    <bind-xml name="field"/>
  </field>
</class>

<!--class name="tufts.vue.ds.Association">
    <field name="schema1">
      <bind-xml name="schema" node="element" reference="true"/>
    </field>
    <field name="schema2">
      <bind-xml name="schema" node="element" reference="true"/>
    </field>
</class -->


<class name="tufts.vue.ds.XMLIngest$XmlSchema" extends="tufts.vue.ds.Schema" identity="mapLocalID">
</class>

</mapping>

  
  <!--
  <class name="tufts.vue.LWNode$NodeShape">
    <map-to xml="nodeShape"/>
    <field name="equalAspect" type="boolean">
      <bind-xml node="attribute"/>
    </field>
    <field name="shape">
      <bind-xml node="element"/>
    </field>
  </class>
  -->
  
