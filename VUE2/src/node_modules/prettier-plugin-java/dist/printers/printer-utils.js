"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.printArrayList = exports.isUniqueMethodInvocation = exports.sortImports = exports.isStatementEmptyStatement = exports.binary = exports.putIntoBraces = exports.getInterfaceBodyDeclarationsSeparator = exports.getClassBodyDeclarationsSeparator = exports.getBlankLinesSeparator = exports.isExplicitLambdaParameter = exports.displaySemicolon = exports.findDeepElementInPartsArray = exports.sortModifiers = exports.sortClassTypeChildren = exports.matchCategory = exports.sortNodes = exports.sortTokens = exports.sortAnnotationIdentifier = exports.rejectAndConcat = exports.rejectAndJoin = exports.rejectSeparators = exports.reject = exports.rejectAndJoinSeps = exports.buildFqn = void 0;
var findIndex_1 = __importDefault(require("lodash/findIndex"));
var findLastIndex_1 = __importDefault(require("lodash/findLastIndex"));
var forEach_1 = __importDefault(require("lodash/forEach"));
var forEachRight_1 = __importDefault(require("lodash/forEachRight"));
var includes_1 = __importDefault(require("lodash/includes"));
var doc_1 = require("prettier/doc");
var utils_1 = require("../types/utils");
var utils_2 = require("../utils");
var comments_utils_1 = require("./comments/comments-utils");
var format_comments_1 = require("./comments/format-comments");
var prettier_builder_1 = require("./prettier-builder");
var indent = doc_1.builders.indent, hardline = doc_1.builders.hardline, line = doc_1.builders.line;
var orderedModifiers = [
    "Public",
    "Protected",
    "Private",
    "Abstract",
    "Default",
    "Static",
    "Final",
    "Transient",
    "Volatile",
    "Synchronized",
    "Native",
    "Sealed",
    "NonSealed",
    "Strictfp"
];
function buildFqn(tokens, dots) {
    return rejectAndJoinSeps(dots ? dots : [], tokens);
}
exports.buildFqn = buildFqn;
function rejectAndJoinSeps(sepTokens, elems, sep) {
    if (!Array.isArray(sepTokens)) {
        return rejectAndJoin(sepTokens, elems);
    }
    var actualElements = reject(elems);
    var res = [];
    for (var i = 0; i < sepTokens.length; i++) {
        res.push(actualElements[i], sepTokens[i]);
        if (sep) {
            res.push(sep);
        }
    }
    res.push.apply(res, actualElements.slice(sepTokens.length));
    return (0, prettier_builder_1.concat)(res);
}
exports.rejectAndJoinSeps = rejectAndJoinSeps;
function reject(elems) {
    return elems.filter(function (item) {
        if (typeof item === "string") {
            return item !== "";
        }
        // eslint-ignore next - We want the conversion to boolean!
        // @ts-ignore
        return item != false && item !== undefined;
    });
}
exports.reject = reject;
function rejectSeparators(separators, elems) {
    var realElements = reject(elems);
    var realSeparators = [];
    for (var i = 0; i < realElements.length - 1; i++) {
        if (realElements[i] !== "") {
            realSeparators.push(separators[i]);
        }
    }
    return realSeparators;
}
exports.rejectSeparators = rejectSeparators;
function rejectAndJoin(sep, elems) {
    var actualElements = reject(elems);
    return (0, prettier_builder_1.join)(sep, actualElements);
}
exports.rejectAndJoin = rejectAndJoin;
function rejectAndConcat(elems) {
    var actualElements = reject(elems);
    return (0, prettier_builder_1.concat)(actualElements);
}
exports.rejectAndConcat = rejectAndConcat;
function sortAnnotationIdentifier(annotations, identifiers) {
    var tokens = __spreadArray([], identifiers, true);
    if (annotations && annotations.length > 0) {
        tokens = __spreadArray(__spreadArray([], tokens, true), annotations, true);
    }
    return tokens.sort(function (a, b) {
        var startOffset1 = (0, utils_1.isCstNode)(a)
            ? a.children.At[0].startOffset
            : a.startOffset;
        var startOffset2 = (0, utils_1.isCstNode)(b)
            ? b.children.At[0].startOffset
            : b.startOffset;
        return startOffset1 - startOffset2;
    });
}
exports.sortAnnotationIdentifier = sortAnnotationIdentifier;
function sortTokens(values) {
    var tokens = [];
    (0, forEach_1.default)(values, function (argument) {
        if (argument) {
            tokens = tokens.concat(argument);
        }
    });
    return tokens.sort(function (a, b) {
        return a.startOffset - b.startOffset;
    });
}
exports.sortTokens = sortTokens;
function sortNodes(values) {
    var nodes = [];
    (0, forEach_1.default)(values, function (argument) {
        if (argument) {
            nodes = nodes.concat(argument);
        }
    });
    return nodes.sort(function (a, b) {
        var aOffset = a.location.startOffset;
        var bOffset = b.location.startOffset;
        return aOffset - bOffset;
    });
}
exports.sortNodes = sortNodes;
function matchCategory(token, categoryName) {
    var labels = (token.tokenType.CATEGORIES || []).map(function (category) {
        return category.LABEL;
    });
    return labels.indexOf(categoryName) !== -1;
}
exports.matchCategory = matchCategory;
function sortClassTypeChildren(annotations, typeArguments, identifiers, dots) {
    var tokens = __spreadArray([], identifiers, true);
    if (annotations && annotations.length > 0) {
        tokens = __spreadArray(__spreadArray([], tokens, true), annotations, true);
    }
    if (typeArguments && typeArguments.length > 0) {
        tokens = __spreadArray(__spreadArray([], tokens, true), typeArguments, true);
    }
    if (dots && dots.length > 0) {
        tokens = __spreadArray(__spreadArray([], tokens, true), dots, true);
    }
    return tokens.sort(function (a, b) {
        var startOffsetA = (0, utils_1.isCstNode)(a)
            ? a.children.At
                ? a.children.At[0].startOffset
                : a.children.Less[0].startOffset
            : a.startOffset;
        var startOffsetB = (0, utils_1.isCstNode)(b)
            ? b.children.At
                ? b.children.At[0].startOffset
                : b.children.Less[0].startOffset
            : b.startOffset;
        return startOffsetA - startOffsetB;
    });
}
exports.sortClassTypeChildren = sortClassTypeChildren;
function sortModifiers(modifiers) {
    var firstAnnotations = [];
    var otherModifiers = [];
    var lastAnnotations = [];
    var hasOtherModifier = false;
    /**
     * iterate in reverse order because we special-case
     * type annotations which come after all other
     * modifiers
     */
    (0, forEachRight_1.default)(modifiers, function (modifier) {
        var isAnnotation = modifier.children.annotation !== undefined;
        var isTypeAnnotation = isAnnotation &&
            (modifier.name === "methodModifier" ||
                modifier.name === "interfaceMethodModifier" ||
                modifier.name === "fieldModifier");
        if (isAnnotation) {
            if (isTypeAnnotation && !hasOtherModifier) {
                lastAnnotations.unshift(modifier);
            }
            else {
                firstAnnotations.unshift(modifier);
            }
        }
        else {
            otherModifiers.unshift(modifier);
            hasOtherModifier = true;
        }
    });
    /**
     * if there are only annotations, move everything from
     * lastAnnotations to firstAnnotations
     */
    if (!hasOtherModifier) {
        firstAnnotations = firstAnnotations.concat(lastAnnotations);
        lastAnnotations = [];
    }
    otherModifiers.sort(function (a, b) {
        var modifierIndexA = orderedModifiers.indexOf(Object.keys(a.children)[0]);
        var modifierIndexB = orderedModifiers.indexOf(Object.keys(b.children)[0]);
        return modifierIndexA - modifierIndexB;
    });
    return [firstAnnotations, otherModifiers.concat(lastAnnotations)];
}
exports.sortModifiers = sortModifiers;
function findDeepElementInPartsArray(item, elt) {
    if (Array.isArray(item)) {
        if ((0, includes_1.default)(item, elt)) {
            return true;
        }
        for (var i = 0; i < item.length; i++) {
            if (findDeepElementInPartsArray(item[i], elt)) {
                return true;
            }
        }
    }
    else {
        for (var key in item) {
            if (typeof item[key] === "object" &&
                findDeepElementInPartsArray(item[key], elt)) {
                return true;
            }
        }
    }
    return false;
}
exports.findDeepElementInPartsArray = findDeepElementInPartsArray;
function displaySemicolon(token, params) {
    if (params !== undefined && params.allowEmptyStatement) {
        return (0, format_comments_1.printTokenWithComments)(token);
    }
    if (!(0, comments_utils_1.hasComments)(token)) {
        return "";
    }
    token.image = "";
    return (0, format_comments_1.printTokenWithComments)(token);
}
exports.displaySemicolon = displaySemicolon;
function isExplicitLambdaParameter(ctx) {
    return (ctx &&
        ctx.lambdaParameterList &&
        ctx.lambdaParameterList[0] &&
        ctx.lambdaParameterList[0].children &&
        ctx.lambdaParameterList[0].children.explicitLambdaParameterList);
}
exports.isExplicitLambdaParameter = isExplicitLambdaParameter;
function getBlankLinesSeparator(ctx, separator) {
    if (separator === void 0) { separator = hardline; }
    if (ctx === undefined) {
        return [];
    }
    var separators = [];
    for (var i = 0; i < ctx.length - 1; i++) {
        var node = ctx[i];
        var previousRuleEndLineWithComment = (0, comments_utils_1.hasTrailingComments)(node)
            ? node.trailingComments[node.trailingComments.length - 1].endLine
            : node.location.endLine;
        var nextNode = ctx[i + 1];
        var nextRuleStartLineWithComment = (0, comments_utils_1.hasLeadingComments)(nextNode)
            ? nextNode.leadingComments[0].startLine
            : nextNode.location.startLine;
        if (nextRuleStartLineWithComment - previousRuleEndLineWithComment > 1) {
            separators.push([hardline, hardline]);
        }
        else {
            separators.push(separator);
        }
    }
    return separators;
}
exports.getBlankLinesSeparator = getBlankLinesSeparator;
var isTwoHardLine = function (userBlankLinesSeparator) {
    if (!Array.isArray(userBlankLinesSeparator)) {
        return false;
    }
    return (userBlankLinesSeparator.length === 2 &&
        userBlankLinesSeparator[0] === hardline &&
        userBlankLinesSeparator[1] === hardline);
};
function getDeclarationsSeparator(declarations, needLineDeclaration, isSemicolon) {
    var declarationsWithoutEmptyStatements = declarations.filter(function (declaration) { return !isSemicolon(declaration); });
    var userBlankLinesSeparators = getBlankLinesSeparator(declarationsWithoutEmptyStatements);
    var additionalBlankLines = declarationsWithoutEmptyStatements.map(needLineDeclaration);
    var separators = [];
    var indexNextNotEmptyDeclaration = 0;
    for (var i = 0; i < declarations.length - 1; i++) {
        // if the empty statement has comments
        // we want to print them on their own line
        if (isSemicolon(declarations[i])) {
            if ((0, comments_utils_1.hasComments)(declarations[i])) {
                separators.push(hardline);
            }
        }
        else if (indexNextNotEmptyDeclaration <
            declarationsWithoutEmptyStatements.length - 1) {
            var isNextSeparatorTwoHardLine = isTwoHardLine(userBlankLinesSeparators[indexNextNotEmptyDeclaration]);
            var additionalSep = !isNextSeparatorTwoHardLine &&
                (additionalBlankLines[indexNextNotEmptyDeclaration + 1] ||
                    additionalBlankLines[indexNextNotEmptyDeclaration])
                ? hardline
                : "";
            separators.push((0, prettier_builder_1.concat)([
                userBlankLinesSeparators[indexNextNotEmptyDeclaration],
                additionalSep
            ]));
            indexNextNotEmptyDeclaration += 1;
        }
    }
    return separators;
}
function needLineClassBodyDeclaration(declaration) {
    if (declaration.children.classMemberDeclaration === undefined) {
        return true;
    }
    var classMemberDeclaration = declaration.children.classMemberDeclaration[0];
    if (classMemberDeclaration.children.fieldDeclaration !== undefined) {
        var fieldDeclaration = classMemberDeclaration.children.fieldDeclaration[0];
        if (fieldDeclaration.children.fieldModifier !== undefined &&
            hasAnnotation(fieldDeclaration.children.fieldModifier) &&
            hasNonTrailingAnnotation(fieldDeclaration.children.fieldModifier)) {
            return true;
        }
        return false;
    }
    else if (classMemberDeclaration.children.Semicolon !== undefined) {
        return false;
    }
    return true;
}
function needLineInterfaceMemberDeclaration(declaration) {
    if (declaration.children.constantDeclaration !== undefined) {
        var constantDeclaration = declaration.children.constantDeclaration[0];
        if (constantDeclaration.children.constantModifier !== undefined &&
            hasAnnotation(constantDeclaration.children.constantModifier) &&
            hasNonTrailingAnnotation(constantDeclaration.children.constantModifier)) {
            return true;
        }
        return false;
    }
    else if (declaration.children.interfaceMethodDeclaration !== undefined) {
        var interfaceMethodDeclaration = declaration.children.interfaceMethodDeclaration[0];
        if (interfaceMethodDeclaration.children.interfaceMethodModifier !==
            undefined &&
            hasNonTrailingAnnotation(interfaceMethodDeclaration.children.interfaceMethodModifier)) {
            return true;
        }
        return false;
    }
    return true;
}
function isClassBodyDeclarationASemicolon(classBodyDeclaration) {
    if (classBodyDeclaration.children.classMemberDeclaration) {
        if (classBodyDeclaration.children.classMemberDeclaration[0].children
            .Semicolon !== undefined) {
            return true;
        }
    }
    return false;
}
function isInterfaceMemberASemicolon(interfaceMemberDeclaration) {
    return interfaceMemberDeclaration.children.Semicolon !== undefined;
}
function hasAnnotation(modifiers) {
    return modifiers.some(function (modifier) { return modifier.children.annotation !== undefined; });
}
/**
 * Return true if there is a modifier that does not come after all other modifiers
 * It is useful to know if sortModifiers will add an annotation before other modifiers
 *
 * @param modifiers
 * @returns {boolean}
 */
function hasNonTrailingAnnotation(modifiers) {
    var firstAnnotationIndex = (0, findIndex_1.default)(modifiers, function (modifier) { return modifier.children.annotation !== undefined; });
    var lastNonAnnotationIndex = (0, findLastIndex_1.default)(modifiers, function (modifier) { return modifier.children.annotation === undefined; });
    return (firstAnnotationIndex < lastNonAnnotationIndex ||
        lastNonAnnotationIndex === -1);
}
function getClassBodyDeclarationsSeparator(classBodyDeclarationContext) {
    return getDeclarationsSeparator(classBodyDeclarationContext, needLineClassBodyDeclaration, isClassBodyDeclarationASemicolon);
}
exports.getClassBodyDeclarationsSeparator = getClassBodyDeclarationsSeparator;
function getInterfaceBodyDeclarationsSeparator(interfaceMemberDeclarationContext) {
    return getDeclarationsSeparator(interfaceMemberDeclarationContext, needLineInterfaceMemberDeclaration, isInterfaceMemberASemicolon);
}
exports.getInterfaceBodyDeclarationsSeparator = getInterfaceBodyDeclarationsSeparator;
function getAndRemoveLeadingComment(doc) {
    var isTokenWithLeadingComment = typeof doc !== "string" && "leadingComments" in doc;
    if (!isTokenWithLeadingComment) {
        return [];
    }
    var leadingComments = (0, format_comments_1.getTokenLeadingComments)(doc);
    delete doc.leadingComments;
    return leadingComments;
}
function putIntoBraces(argument, separator, LBrace, RBrace) {
    var rightBraceLeadingComments = getAndRemoveLeadingComment(RBrace);
    var lastBreakLine = 
    // check if last element of the array is a line
    rightBraceLeadingComments.length !== 0 &&
        rightBraceLeadingComments[rightBraceLeadingComments.length - 1] === hardline
        ? rightBraceLeadingComments.pop()
        : separator;
    var contentInsideBraces;
    if ((0, utils_2.isEmptyDoc)(argument)) {
        if (rightBraceLeadingComments.length === 0) {
            return (0, prettier_builder_1.concat)([LBrace, RBrace]);
        }
        contentInsideBraces = __spreadArray([separator], rightBraceLeadingComments, true);
    }
    else if (rightBraceLeadingComments.length !== 0) {
        contentInsideBraces = __spreadArray([
            separator,
            argument,
            separator
        ], rightBraceLeadingComments, true);
    }
    else {
        contentInsideBraces = [separator, argument];
    }
    return (0, prettier_builder_1.group)(rejectAndConcat([
        LBrace,
        indent((0, prettier_builder_1.concat)(contentInsideBraces)),
        lastBreakLine,
        RBrace
    ]));
}
exports.putIntoBraces = putIntoBraces;
function binary(nodes, tokens, isRoot) {
    if (isRoot === void 0) { isRoot = false; }
    var levelOperator;
    var levelPrecedence;
    var level = [];
    while (tokens.length) {
        var nextOperator = getOperator(tokens);
        var nextPrecedence = getOperatorPrecedence(nextOperator);
        if (levelPrecedence === undefined || nextPrecedence === levelPrecedence) {
            var tokenLength = ["<<", ">>", ">>>"].includes(nextOperator)
                ? nextOperator.length
                : 1;
            var operator = (0, prettier_builder_1.concat)(tokens.splice(0, tokenLength));
            if (levelOperator !== undefined &&
                needsParentheses(levelOperator, nextOperator)) {
                level.push(nodes.shift());
                level = [
                    (0, prettier_builder_1.concat)(["(", (0, prettier_builder_1.group)(indent((0, prettier_builder_1.join)(line, level))), ") ", operator])
                ];
            }
            else {
                level.push((0, prettier_builder_1.join)(" ", [nodes.shift(), operator]));
            }
            levelOperator = nextOperator;
            levelPrecedence = nextPrecedence;
        }
        else if (nextPrecedence < levelPrecedence) {
            level.push(nodes.shift());
            if (isRoot) {
                var content_1 = (0, prettier_builder_1.group)(indent((0, prettier_builder_1.join)(line, level)));
                nodes.unshift(levelOperator !== undefined &&
                    needsParentheses(levelOperator, nextOperator)
                    ? (0, prettier_builder_1.concat)(["(", content_1, ")"])
                    : content_1);
                level = [];
                levelOperator = undefined;
                levelPrecedence = undefined;
            }
            else {
                return (0, prettier_builder_1.group)((0, prettier_builder_1.join)(line, level));
            }
        }
        else {
            var content_2 = indent(binary(nodes, tokens));
            nodes.unshift(levelOperator !== undefined &&
                needsParentheses(nextOperator, levelOperator)
                ? (0, prettier_builder_1.concat)(["(", content_2, ")"])
                : content_2);
        }
    }
    level.push(nodes.shift());
    var content = (0, prettier_builder_1.group)((0, prettier_builder_1.join)(line, level));
    return levelOperator === "=" ? indent(content) : content;
}
exports.binary = binary;
function getOperator(tokens) {
    if (!tokens.length) {
        return "";
    }
    var _a = tokens[0], image = _a.image, startOffset = _a.startOffset;
    if (!["<", ">"].includes(image)) {
        return image;
    }
    var repeatedTokenCount = 1;
    for (var i = 1; i < Math.min(3, tokens.length); i++) {
        var token = tokens[i];
        if (token.image !== image || token.startOffset !== startOffset + i) {
            break;
        }
        repeatedTokenCount++;
    }
    if (repeatedTokenCount === 1) {
        return image;
    }
    if (image === "<") {
        return "<<";
    }
    else if (repeatedTokenCount == 2) {
        return ">>";
    }
    else {
        return ">>>";
    }
}
var PRECEDENCES_BY_OPERATOR = new Map([
    ["||"],
    ["&&"],
    ["|"],
    ["^"],
    ["&"],
    ["==", "!="],
    ["<", ">", "<=", ">=", "instanceof"],
    ["<<", ">>", ">>>"],
    ["+", "-"],
    ["*", "/", "%"]
].flatMap(function (operators, index) { return operators.map(function (operator) { return [operator, index]; }); }));
function getOperatorPrecedence(operator) {
    var _a;
    return (_a = PRECEDENCES_BY_OPERATOR.get(operator)) !== null && _a !== void 0 ? _a : -1;
}
function needsParentheses(operator, parentOperator) {
    return ((operator === "&&" && parentOperator === "||") ||
        (["|", "^", "&", "<<", ">>", ">>>"].includes(parentOperator) &&
            getOperatorPrecedence(operator) >
                getOperatorPrecedence(parentOperator)) ||
        [operator, parentOperator].every(function (o) { return ["==", "!="].includes(o); }) ||
        [operator, parentOperator].every(function (o) { return ["<<", ">>", ">>>"].includes(o); }) ||
        (operator === "*" && parentOperator === "/") ||
        (operator === "/" && parentOperator === "*") ||
        (operator === "%" && ["+", "-", "*", "/"].includes(parentOperator)) ||
        (["*", "/"].includes(operator) && parentOperator === "%"));
}
function isStatementEmptyStatement(statement) {
    return (statement === ";" || (Array.isArray(statement) && statement[0] === ";"));
}
exports.isStatementEmptyStatement = isStatementEmptyStatement;
function sortImports(imports) {
    var staticImports = [];
    var nonStaticImports = [];
    if (imports !== undefined) {
        for (var i = 0; i < imports.length; i++) {
            if (imports[i].children.Static !== undefined) {
                staticImports.push(imports[i]);
            }
            else if (imports[i].children.emptyStatement === undefined) {
                nonStaticImports.push(imports[i]);
            }
        }
        // TODO: Could be optimized as we could expect that the array is already almost sorted
        var comparator = function (first, second) {
            return compareFqn(first.children.packageOrTypeName[0], second.children.packageOrTypeName[0]);
        };
        staticImports.sort(comparator);
        nonStaticImports.sort(comparator);
    }
    return {
        staticImports: staticImports,
        nonStaticImports: nonStaticImports
    };
}
exports.sortImports = sortImports;
function compareFqn(packageOrTypeNameFirst, packageOrTypeNameSecond) {
    var identifiersFirst = packageOrTypeNameFirst.children.Identifier;
    var identifiersSecond = packageOrTypeNameSecond.children.Identifier;
    var minParts = Math.min(identifiersFirst.length, identifiersSecond.length);
    for (var i = 0; i < minParts; i++) {
        if (identifiersFirst[i].image < identifiersSecond[i].image) {
            return -1;
        }
        else if (identifiersFirst[i].image > identifiersSecond[i].image) {
            return 1;
        }
    }
    if (identifiersFirst.length < identifiersSecond.length) {
        return -1;
    }
    else if (identifiersFirst.length > identifiersSecond.length) {
        return 1;
    }
    return 0;
}
function isUniqueMethodInvocation(primarySuffixes) {
    if (primarySuffixes === undefined) {
        return 0;
    }
    var count = 0;
    primarySuffixes.forEach(function (primarySuffix) {
        if (primarySuffix.children.methodInvocationSuffix !== undefined) {
            count++;
            if (count > 1) {
                return 2;
            }
        }
    });
    return count;
}
exports.isUniqueMethodInvocation = isUniqueMethodInvocation;
function printArrayList(_a) {
    var list = _a.list, extraComma = _a.extraComma, LCurly = _a.LCurly, RCurly = _a.RCurly, trailingComma = _a.trailingComma;
    var optionalComma;
    if (trailingComma !== "none" && list !== "") {
        optionalComma = extraComma
            ? (0, prettier_builder_1.ifBreak)(extraComma[0], __assign(__assign({}, extraComma[0]), { image: "" }))
            : (0, prettier_builder_1.ifBreak)(",", "");
    }
    else {
        optionalComma = extraComma ? __assign(__assign({}, extraComma[0]), { image: "" }) : "";
    }
    return putIntoBraces(rejectAndConcat([list, optionalComma]), line, LCurly, RCurly);
}
exports.printArrayList = printArrayList;
